<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TimeSlice App</title>
    
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React Libraries -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- Babel to compile JSX in the browser -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700;900&display=swap" rel="stylesheet">
    
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
    </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900">
    <div id="root"></div>

    <script type="text/babel">
        // This is the entire React application code.
        // It will be compiled by Babel directly in the browser.

        const { useState, useEffect, useMemo, useRef } = React;

        // Helper function to format seconds into a readable time string (HH:MM:SS)
        const formatTime = (totalSeconds) => {
            if (isNaN(totalSeconds) || totalSeconds < 0) return "00:00:00";
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = Math.floor(totalSeconds % 60);
            return [hours, minutes, seconds].map(v => v.toString().padStart(2, '0')).join(':');
        };

        const activityColors = [
            '#4f46e5', '#7c3aed', '#db2777', '#f97316', '#eab308', 
            '#22c55e', '#14b8a6', '#0ea5e9', '#6366f1', '#a855f7'
        ];

        // --- Draggable Stacked Bar Component ---
        const StackedBar = ({ activities, setActivities }) => {
            const barRef = useRef(null);
            const draggingIndex = useRef(null);
            const startX = useRef(0);
            const initialPercentages = useRef([]);

            const handleMouseDown = (e, index) => {
                e.preventDefault();
                draggingIndex.current = index;
                startX.current = e.clientX;
                initialPercentages.current = activities.map(a => a.percentage);
                window.addEventListener('mousemove', handleMouseMove);
                window.addEventListener('mouseup', handleMouseUp);
            };

            const handleMouseMove = (e) => {
                if (draggingIndex.current === null) return;
                
                const barWidth = barRef.current.offsetWidth;
                if (barWidth === 0) return;
                const dx = e.clientX - startX.current;
                const percentageDelta = (dx / barWidth) * 100;
                
                const leftActivityIndex = draggingIndex.current;
                const rightActivityIndex = draggingIndex.current + 1;
                
                const newPercentages = [...initialPercentages.current];

                const leftPct = newPercentages[leftActivityIndex];
                const rightPct = newPercentages[rightActivityIndex];
                
                let actualDelta = percentageDelta;
                
                if (percentageDelta > 0) {
                    actualDelta = Math.min(percentageDelta, rightPct);
                } else {
                    actualDelta = Math.max(percentageDelta, -leftPct);
                }

                newPercentages[leftActivityIndex] += actualDelta;
                newPercentages[rightActivityIndex] -= actualDelta;

                setActivities(current => current.map((act, i) => ({...act, percentage: newPercentages[i] })));
            };

            const handleMouseUp = () => {
                if (draggingIndex.current === null) return;
                draggingIndex.current = null;
                window.removeEventListener('mousemove', handleMouseMove);
                window.removeEventListener('mouseup', handleMouseUp);
                
                setActivities(current => {
                    const rounded = current.map(a => ({ ...a, percentage: Math.round(a.percentage) }));
                    const total = rounded.reduce((s, a) => s + a.percentage, 0);
                    const error = 100 - total;
                    if (error !== 0 && rounded.length > 0) {
                        const activityToFix = rounded.find(a => a.percentage + error >= 0) || rounded[0];
                        activityToFix.percentage += error;
                    }
                    return rounded;
                });
            };
            
            useEffect(() => {
                return () => {
                    window.removeEventListener('mousemove', handleMouseMove);
                    window.removeEventListener('mouseup', handleMouseUp);
                };
            }, []);

            return (
                <div ref={barRef} className="w-full h-12 flex rounded-lg overflow-hidden bg-gray-200 dark:bg-gray-700 select-none">
                    {activities.map((activity, index) => (
                        <React.Fragment key={activity.id}>
                            <div 
                                className="h-full flex items-center justify-center text-white font-bold text-sm"
                                style={{
                                    width: `${activity.percentage}%`,
                                    backgroundColor: activityColors[index % activityColors.length],
                                    transition: 'width 150ms ease-out'
                                }}
                            >
                               {Math.round(activity.percentage) > 5 ? `${Math.round(activity.percentage)}%` : ''}
                            </div>
                            {index < activities.length - 1 && (
                                <div 
                                    className="h-full w-2 bg-white dark:bg-gray-500 hover:bg-indigo-300 dark:hover:bg-indigo-600 cursor-ew-resize transition-colors"
                                    onMouseDown={(e) => handleMouseDown(e, index)}
                                />
                            )}
                        </React.Fragment>
                    ))}
                </div>
            );
        }

        // --- Main App Component ---
        function App() {
            // --- STATE MANAGEMENT ---
            const [screen, setScreen] = useState('setup'); 
            const [totalTimeInSeconds, setTotalTimeInSeconds] = useState(3 * 3600); 

            const [setupActivities, setSetupActivities] = useState([
                { id: 1, name: 'Cleaning', percentage: 25 },
                { id: 2, name: 'Gaming', percentage: 50 },
                { id: 3, name: 'Priority Tasks', percentage: 25 },
            ]);
            const [sessionActivities, setSessionActivities] = useState([]);
            const [timerState, setTimerState] = useState({isActive: false, currentActivityIndex: 0, totalTimeRemaining: 0});
            
            // --- DERIVED STATE & MEMOS ---
            const totalPercentage = useMemo(() => setupActivities.reduce((sum, act) => sum + Math.round(act.percentage), 0), [setupActivities]);
            
            // --- TIMER LOGIC ---
            useEffect(() => {
                let interval = null;
                if (timerState.isActive && timerState.totalTimeRemaining > 0) {
                    interval = setInterval(() => {
                        setSessionActivities(prevActivities => {
                            const newActivities = [...prevActivities];
                            const currentActivity = newActivities[timerState.currentActivityIndex];
                            if (currentActivity && currentActivity.remainingDuration > 0) {
                                currentActivity.remainingDuration -= 1;
                                currentActivity.timeSpent += 1;
                            }
                            return newActivities;
                        });
                        setTimerState(prev => ({ ...prev, totalTimeRemaining: prev.totalTimeRemaining - 1 }));
                        const currentActivity = sessionActivities[timerState.currentActivityIndex];
                        if (currentActivity && currentActivity.remainingDuration <= 0) {
                           const nextIndex = sessionActivities.findIndex((act, index) => index > timerState.currentActivityIndex && act.remainingDuration > 0);
                           if(nextIndex !== -1) {
                               setTimerState(prev => ({...prev, currentActivityIndex: nextIndex}));
                           } else {
                               const firstIndex = sessionActivities.findIndex(act => act.remainingDuration > 0);
                                if (firstIndex !== -1) setTimerState(prev => ({...prev, currentActivityIndex: firstIndex}));
                           }
                        }
                    }, 1000);
                } else if (timerState.totalTimeRemaining <= 0 && timerState.isActive) {
                    setTimerState(prev => ({ ...prev, isActive: false }));
                    setScreen('completed');
                }
                return () => clearInterval(interval);
            }, [timerState.isActive, timerState.totalTimeRemaining, timerState.currentActivityIndex, sessionActivities]);


            // --- HANDLER FUNCTIONS ---
            const handleAddActivity = () => {
                setSetupActivities(prev => {
                    if (prev.length === 0) return [{ id: Date.now(), name: `New Activity`, percentage: 100 }];
                    
                    const largestActivity = [...prev].sort((a,b) => b.percentage - a.percentage)[0];
                    const newPercentage = Math.min(10, Math.floor(largestActivity.percentage / 2));
                    
                    if (newPercentage > 0) {
                        const updated = prev.map(act => act.id === largestActivity.id ? {...act, percentage: act.percentage - newPercentage} : act);
                        const final = [...updated, { id: Date.now(), name: `New Activity`, percentage: newPercentage }];
                        
                        const currentTotal = final.reduce((sum, act) => sum + act.percentage, 0);
                        const roundingError = 100 - currentTotal;
                        if(roundingError !== 0 && final.length > 0){
                           final.sort((a,b) => b.percentage - a.percentage)[0].percentage += roundingError;
                        }
                        return final.map(a => ({...a, percentage: Math.round(a.percentage)}));
                    }
                    return prev;
                });
            };
            
            const handleRemoveActivity = (id) => {
                const activityToRemove = setupActivities.find(a => a.id === id);
                if (!activityToRemove || setupActivities.length <= 1) return;

                const removedPercentage = activityToRemove.percentage;
                let remainingActivities = setupActivities.filter(a => a.id !== id);
                
                const totalRemaining = remainingActivities.reduce((s, a) => s + a.percentage, 0);
                if (totalRemaining > 0) {
                    remainingActivities = remainingActivities.map(a => ({...a, percentage: a.percentage + removedPercentage * (a.percentage/totalRemaining)}));
                } else {
                     remainingActivities.forEach(a => a.percentage += removedPercentage / remainingActivities.length);
                }
                
                const finalTotal = remainingActivities.reduce((s, a) => s + Math.round(a.percentage), 0);
                if (remainingActivities.length > 0) {
                    remainingActivities[0].percentage += 100 - finalTotal;
                }
                setSetupActivities(remainingActivities.map(a => ({...a, percentage: Math.round(a.percentage)})));
            };
            
            const handleUpdateName = (id, value) => setSetupActivities(setupActivities.map(a => (a.id === id ? { ...a, name: value } : a)));
            
            const handleUpdatePercentage = (id, value) => {
                let targetValue = parseInt(value, 10);
                if (isNaN(targetValue)) return;
                targetValue = Math.max(0, Math.min(100, targetValue));

                setSetupActivities(currentActivities => {
                    if (currentActivities.length <= 1) return currentActivities.map(a => ({...a, percentage: 100}));

                    const sourceActivity = currentActivities.find(a => a.id === id);
                    if (!sourceActivity) return currentActivities;

                    const diff = targetValue - sourceActivity.percentage;
                    if (diff === 0) return currentActivities;

                    const otherActivities = currentActivities.filter(a => a.id !== id);
                    const othersTotal = otherActivities.reduce((sum, act) => sum + act.percentage, 0);

                    let finalActivities;

                    if (othersTotal < diff) {
                        const totalToDistribute = sourceActivity.percentage + othersTotal;
                        finalActivities = currentActivities.map(a => (a.id === id ? { ...a, percentage: totalToDistribute } : {...a, percentage: 0}));
                    } else if (othersTotal > 0) {
                        finalActivities = currentActivities.map(activity => {
                            if (activity.id === id) {
                                return { ...activity, percentage: targetValue };
                            } else {
                                const share = activity.percentage / othersTotal;
                                return { ...activity, percentage: activity.percentage - (diff * share) };
                            }
                        });
                    } else { 
                         finalActivities = currentActivities.map(a => ({...a, percentage: a.id === id ? 100 : 0}));
                    }

                    const currentTotal = finalActivities.reduce((sum, act) => sum + act.percentage, 0);
                    const roundingError = 100 - currentTotal;
                    if (Math.abs(roundingError) > 0.001) {
                        const activityToAdjust = finalActivities.find(a => a.id !== id && (a.percentage + roundingError) >= 0) || finalActivities.find(a => a.id === id);
                        if (activityToAdjust) activityToAdjust.percentage += roundingError;
                    }
                    
                    return finalActivities.map(a => ({...a, percentage: Math.round(a.percentage)}));
                });
            };

            const handleTimeChange = (e) => {
                const { name, value } = e.target;
                const currentHours = Math.floor(totalTimeInSeconds / 3600);
                const currentMinutes = Math.floor((totalTimeInSeconds % 3600) / 60);
                let newHours = currentHours, newMinutes = currentMinutes;
                if (name === 'hours') newHours = parseInt(value, 10) || 0;
                if (name === 'minutes') newMinutes = parseInt(value, 10) || 0;
                setTotalTimeInSeconds(newHours * 3600 + newMinutes * 60);
            };

            const handleStartTimer = () => {
                if (totalPercentage !== 100) return;
                let remainingSeconds = totalTimeInSeconds;
                const calculated = setupActivities.map(activity => {
                    const duration = Math.floor(totalTimeInSeconds * (activity.percentage / 100));
                    remainingSeconds -= duration;
                    return { ...activity, duration, remainingDuration: duration, timeSpent: 0 };
                });
                if(remainingSeconds > 0 && calculated.length > 0) {
                    calculated.sort((a,b) => b.duration - a.duration)[0].remainingDuration += remainingSeconds;
                }
                setSessionActivities(calculated.sort((a,b) => a.id - b.id));
                setTimerState({isActive: true, currentActivityIndex: 0, totalTimeRemaining: totalTimeInSeconds});
                setScreen('timer');
            };

            const handleReset = () => {
                setTimerState({ isActive: false, currentActivityIndex: 0, totalTimeRemaining: 0 });
                setSessionActivities([]);
                setScreen('setup');
            };
            
            const handlePauseToggle = () => setTimerState(prev => ({ ...prev, isActive: !prev.isActive }));
            const handleSwitchActivity = (index) => { if (sessionActivities[index].remainingDuration > 0) setTimerState(prev => ({ ...prev, currentActivityIndex: index })); };

            // --- RENDER FUNCTIONS ---
            
            const renderSetupScreen = () => (
                <div className="p-6 md:p-8 bg-white dark:bg-gray-800 rounded-2xl shadow-2xl w-full max-w-2xl">
                    <h1 className="text-3xl md:text-4xl font-bold text-gray-800 dark:text-white mb-2 text-center">TimeSlice</h1>
                    <p className="text-gray-600 dark:text-gray-300 mb-6 text-center">Drag the dividers or type percentages to set your time slices.</p>
                    
                    <div className="mb-6">
                        <StackedBar activities={setupActivities} setActivities={setSetupActivities} />
                    </div>

                    <div className="mb-6 bg-gray-50 dark:bg-gray-700/50 p-4 rounded-lg">
                        <h2 className="text-lg font-semibold text-gray-700 dark:text-gray-200 mb-3">1. Set Total Duration</h2>
                        <div className="flex items-center space-x-4">
                            <div className="flex-1"><label htmlFor="hours" className="block text-sm font-medium text-gray-500 dark:text-gray-400">Hours</label><input type="number" name="hours" id="hours" value={Math.floor(totalTimeInSeconds / 3600)} onChange={handleTimeChange} className="mt-1 w-full p-2 text-center bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm" /></div>
                            <span className="text-2xl font-bold text-gray-500 dark:text-gray-400 pt-5">:</span>
                            <div className="flex-1"><label htmlFor="minutes" className="block text-sm font-medium text-gray-500 dark:text-gray-400">Minutes</label><input type="number" name="minutes" id="minutes" value={Math.floor((totalTimeInSeconds % 3600) / 60)} onChange={handleTimeChange} className="mt-1 w-full p-2 text-center bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm" /></div>
                        </div>
                    </div>
                    
                    <div className="mb-6">
                        <h2 className="text-lg font-semibold text-gray-700 dark:text-gray-200 mb-3">2. Activities</h2>
                         <div className="space-y-3">{setupActivities.map((activity, index) => (<div key={activity.id} className="flex items-center space-x-3 p-2 bg-gray-50 dark:bg-gray-700/50 rounded-lg">
                            <div className="w-5 h-5 rounded-full" style={{backgroundColor: activityColors[index % activityColors.length]}}></div>
                            <input type="text" value={activity.name} onChange={(e) => handleUpdateName(activity.id, e.target.value)} className="flex-grow p-2 bg-transparent dark:text-white font-semibold" />
                            <input type="number" value={Math.round(activity.percentage)} onChange={(e) => handleUpdatePercentage(activity.id, e.target.value)} className="w-20 p-2 text-center bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-600 rounded-md" />
                            <span className="font-semibold text-gray-500 dark:text-gray-400">%</span>
                            <button onClick={() => handleRemoveActivity(activity.id)} className="p-1 text-red-500 hover:bg-red-100 dark:hover:bg-red-900/50 rounded-full"><svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clipRule="evenodd" /></svg></button>
                         </div>))}</div>
                         <button onClick={handleAddActivity} className="mt-4 w-full text-sm font-semibold py-2 px-4 border-2 border-dashed border-gray-300 dark:border-gray-600 text-gray-500 dark:text-gray-400 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-700">+ Add Activity</button>
                    </div>

                    <div className="flex items-center justify-center mt-6">
                        <button onClick={handleStartTimer} disabled={totalPercentage !== 100} className="px-8 py-3 bg-indigo-600 text-white font-bold rounded-lg shadow-lg hover:bg-indigo-700 disabled:bg-gray-400 disabled:cursor-not-allowed">Start Session</button>
                    </div>
                    {totalPercentage !== 100 && (<p className="text-red-500 text-sm mt-2 font-medium text-center">Total must be {100}%. It is {totalPercentage}%</p>)}
                </div>
            );
            
            const renderTimerScreen = () => {
                if (!sessionActivities.length) return null;
                const currentActivity = sessionActivities[timerState.currentActivityIndex];
                const overallProgress = ((totalTimeInSeconds - timerState.totalTimeRemaining) / totalTimeInSeconds) * 100;
                const predictedEndTime = new Date(Date.now() + timerState.totalTimeRemaining * 1000);

                return (
                    <div className="p-6 md:p-8 bg-white dark:bg-gray-800 rounded-2xl shadow-2xl w-full max-w-2xl text-center">
                        <p className="text-indigo-500 dark:text-indigo-400 font-semibold">Current Activity</p>
                        <h1 className="text-3xl md:text-5xl font-bold text-gray-800 dark:text-white my-2 break-words">{currentActivity.name}</h1>
                        <p className="text-7xl md:text-8xl font-mono font-bold text-gray-900 dark:text-white my-6">{formatTime(currentActivity.remainingDuration)}</p>
                        <div className="my-8">
                            <div className="flex justify-between items-baseline text-sm text-gray-500 dark:text-gray-400 mb-2">
                                <span>Overall Progress</span><span>Ends at {predictedEndTime.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</span>
                            </div>
                            <div className="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-4"><div className="bg-green-500 h-4 rounded-full" style={{ width: `${overallProgress}%` }}></div></div>
                        </div>
                        <div className="my-8 space-y-2">
                            <h2 className="text-lg font-semibold text-gray-700 dark:text-gray-200 mb-3">Switch Activity</h2>
                            {sess
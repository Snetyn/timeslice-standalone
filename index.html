<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TimeSlice App</title>
    
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React Libraries -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- Babel to compile JSX in the browser -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700;900&display=swap" rel="stylesheet">
    
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
        }
        .dark body {
            background-color: #111827;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        // This is the entire React application code.
        // It will be compiled by Babel directly in the browser.

        const { useState, useEffect, useMemo, useRef } = React;

        // Helper function to format seconds into a readable time string (HH:MM:SS)
        const formatTime = (totalSeconds) => {
            if (isNaN(totalSeconds) || totalSeconds < 0) return "00:00:00";
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = Math.floor(totalSeconds % 60);
            return [hours, minutes, seconds].map(v => v.toString().padStart(2, '0')).join(':');
        };

        const activityColors = [
            '#4f46e5', '#7c3aed', '#db2777', '#f97316', '#eab308', 
            '#22c55e', '#14b8a6', '#0ea5e9', '#6366f1', '#a855f7'
        ];

        // --- Draggable Stacked Bar Component ---
        const StackedBar = ({ activities, setActivities }) => {
            const barRef = useRef(null);
            const draggingIndex = useRef(null);
            const startX = useRef(0);
            const initialPercentages = useRef([]);

            const handleMouseDown = (e, index) => {
                e.preventDefault();
                draggingIndex.current = index;
                startX.current = e.clientX;
                initialPercentages.current = activities.map(a => a.percentage);
                window.addEventListener('mousemove', handleMouseMove);
                window.addEventListener('mouseup', handleMouseUp);
            };

            const handleMouseMove = (e) => {
                if (draggingIndex.current === null || !barRef.current) return;
                
                const barWidth = barRef.current.offsetWidth;
                if (barWidth === 0) return;
                const dx = e.clientX - startX.current;
                const percentageDelta = (dx / barWidth) * 100;
                
                const leftActivityIndex = draggingIndex.current;
                const rightActivityIndex = draggingIndex.current + 1;
                
                const newPercentages = [...initialPercentages.current];
                const leftPct = newPercentages[leftActivityIndex];
                const rightPct = newPercentages[rightActivityIndex];
                
                let actualDelta = percentageDelta;
                
                if (percentageDelta > 0) {
                    actualDelta = Math.min(percentageDelta, rightPct);
                } else {
                    actualDelta = Math.max(percentageDelta, -leftPct);
                }

                newPercentages[leftActivityIndex] += actualDelta;
                newPercentages[rightActivityIndex] -= actualDelta;

                setActivities(current => current.map((act, i) => ({...act, percentage: newPercentages[i] })));
            };

            const handleMouseUp = () => {
                if (draggingIndex.current === null) return;
                draggingIndex.current = null;
                window.removeEventListener('mousemove', handleMouseMove);
                window.removeEventListener('mouseup', handleMouseUp);
                
                setActivities(current => {
                    const rounded = current.map(a => ({ ...a, percentage: Math.round(a.percentage) }));
                    const total = rounded.reduce((s, a) => s + a.percentage, 0);
                    const error = 100 - total;
                    if (error !== 0 && rounded.length > 0) {
                        const activityToFix = rounded.find(a => a.percentage + error >= 0) || rounded[0];
                        if (activityToFix) {
                            activityToFix.percentage += error;
                        }
                    }
                    return rounded;
                });
            };
            
            useEffect(() => {
                return () => {
                    window.removeEventListener('mousemove', handleMouseMove);
                    window.removeEventListener('mouseup', handleMouseUp);
                };
            }, []);

            return (
                <div ref={barRef} className="w-full h-12 flex rounded-lg overflow-hidden bg-gray-200 dark:bg-gray-700 select-none">
                    {activities.map((activity, index) => (
                        <React.Fragment key={activity.id}>
                            <div 
                                className="h-full flex items-center justify-center text-white font-bold text-sm"
                                style={{
                                    width: `${activity.percentage}%`,
                                    backgroundColor: activityColors[index % activityColors.length],
                                    transition: 'width 50ms ease-out'
                                }}
                            >
                               {Math.round(activity.percentage) > 5 ? `${Math.round(activity.percentage)}%` : ''}
                            </div>
                            {index < activities.length - 1 && (
                                <div 
                                    className="h-full w-2 bg-white dark:bg-gray-500 hover:bg-indigo-300 dark:hover:bg-indigo-600 cursor-ew-resize transition-colors"
                                    onMouseDown={(e) => handleMouseDown(e, index)}
                                />
                            )}
                        </React.Fragment>
                    ))}
                </div>
            );
        }

        // --- Main App Component ---
        function App() {
            const [screen, setScreen] = useState('setup'); 
            const [totalTimeInSeconds, setTotalTimeInSeconds] = useState(3 * 3600); 

            const [setupActivities, setSetupActivities] = useState([
                { id: 1, name: 'Cleaning', percentage: 25 },
                { id: 2, name: 'Gaming', percentage: 50 },
                { id: 3, name: 'Priority Tasks', percentage: 25 },
            ]);
            const [sessionActivities, setSessionActivities] = useState([]);
            const [timerState, setTimerState] = useState({isActive: false, currentActivityIndex: 0, totalTimeRemaining: 0});
            
            const totalPercentage = useMemo(() => setupActivities.reduce((sum, act) => sum + Math.round(act.percentage), 0), [setupActivities]);
            
            useEffect(() => {
                let interval = null;
                if (timerState.isActive && timerState.totalTimeRemaining > 0) {
                    interval = setInterval(() => {
                        setSessionActivities(prevActivities => {
                            const newActivities = [...prevActivities];
                            const currentActivity = newActivities[timerState.currentActivityIndex];
                            if (currentActivity && currentActivity.remainingDuration > 0) {
                                currentActivity.remainingDuration -= 1;
                                currentActivity.timeSpent += 1;
                            }
                            return newActivities;
                        });
                        setTimerState(prev => ({ ...prev, totalTimeRemaining: prev.totalTimeRemaining - 1 }));
                        
                        const currentActivity = sessionActivities[timerState.currentActivityIndex];
                        if (currentActivity && currentActivity.remainingDuration <= 0) {
                           const nextIndex = sessionActivities.findIndex((act, index) => index > timerState.currentActivityIndex && act.remainingDuration > 0);
                           if(nextIndex !== -1) {
                               setTimerState(prev => ({...prev, currentActivityIndex: nextIndex}));
                           } else {
                               const firstIndex = sessionActivities.findIndex(act => act.remainingDuration > 0);
                                if (firstIndex !== -1) {
                                    setTimerState(prev => ({...prev, currentActivityIndex: firstIndex}));
                                }
                           }
                        }
                    }, 1000);
                } else if (timerState.totalTimeRemaining <= 0 && timerState.isActive) {
                    setTimerState(prev => ({ ...prev, isActive: false }));
                    setScreen('completed');
                }
                return () => clearInterval(interval);
            }, [timerState.isActive, timerState.totalTimeRemaining, timerState.currentActivityIndex, sessionActivities]);


            const handleAddActivity = () => {
                setSetupActivities(prev => {
                    if (prev.length === 0) return [{ id: Date.now(), name: `New Activity`, percentage: 100 }];
                    
                    const largestActivity = [...prev].sort((a,b) => b.percentage - a.percentage)[0];
                    const newPercentage = Math.min(10, Math.floor(largestActivity.percentage / 2));
                    
                    if (newPercentage > 0) {
                        const updated = prev.map(act => act.id === largestActivity.id ? {...act, percentage: act.percentage - newPercentage} : act);
                        const final = [...updated, { id: Date.now(), name: `New Activity`, percentage: newPercentage }];
                        
                        const currentTotal = final.reduce((sum, act) => sum + act.percentage, 0);
                        const roundingError = 100 - currentTotal;
                        if(roundingError !== 0 && final.length > 0){
                           final.sort((a,b) => b.percentage - a.percentage)[0].percentage += roundingError;
                        }
                        return final.map(a => ({...a, percentage: Math.round(a.percentage)}));
                    }
                    return prev;
                });
            };
            
            const handleRemoveActivity = (id) => {
                const activityToRemove = setupActivities.find(a => a.id === id);
                if (!activityToRemove || setupActivities.length <= 1) return;

                const removedPercentage = activityToRemove.percentage;
                let remainingActivities = setupActivities.filter(a => a.id !== id);
                
                const totalRemaining = remainingActivities.reduce((s, a) => s + a.percentage, 0);
                if (totalRemaining > 0) {
                    remainingActivities = remainingActivities.map(a => ({...a, percentage: a.percentage + removedPercentage * (a.percentage/totalRemaining)}));
                } else {
                     remainingActivities.forEach(a => a.percentage += removedPercentage / remainingActivities.length);
                }
                
                const finalTotal = remainingActivities.reduce((s, a) => s + Math.round(a.percentage), 0);
                if (remainingActivities.length > 0) {
                    remainingActivities[0].percentage += 100 - finalTotal;
                }
                setSetupActivities(remainingActivities.map(a => ({...a, percentage: Math.round(a.percentage)})));
            };
            
            const handleUpdateName = (id, value) => setSetupActivities(setupActivities.map(a => (a.id === id ? { ...a, name: value } : a)));
            
            const handleUpdatePercentage = (id, value) => {
                let targetValue = parseInt(value, 10);
                if (isNaN(targetValue)) return;
                targetValue = Math.max(0, Math.min(100, targetValue));

                setSetupActivities(currentActivities => {
                    if (currentActivities.length <= 1) return currentActivities.map(a => ({...a, percentage: 100}));

                    const sourceActivity = currentActivities.find(a => a.id === id);
                    if (!sourceActivity) return currentActivities;

                    const diff = targetValue - sourceActivity.percentage;
                    if (diff === 0) return currentActivities;

                    const otherActivities = currentActivities.filter(a => a.id !== id);
                    const othersTotal = otherActivities.reduce((sum, act) => sum + act.percentage, 0);

                    let finalActivities;

                    if (othersTotal < diff) {
                        const totalToDistribute = sourceActivity.percentage + othersTotal;
                        finalActivities = currentActivities.map(a => (a.id === id ? { ...a, percentage: totalToDistribute } : {...a, percentage: 0}));
                    } else if (othersTotal > 0) {
                        finalActivities = currentActivities.map(activity => {
                            if (activity.id === id) {
                                return { ...activity, percentage: targetValue };
                            } else {
                                const share = activity.percentage / othersTotal;
                                return { ...activity, percentage: activity.percentage - (diff * share) };
                            }
                        });
                    } else { 
                         finalActivities = currentActivities.map(a => ({...a, percentage: a.id === id ? 100 : 0}));
                    }

                    const currentTotal = finalActivities.reduce((sum, act) => sum + act.percentage, 0);
                    const roundingError = 100 - currentTotal;
                    if (Math.abs(roundingError) > 0.001) {
                        const activityToAdjust = finalActivities.find(a => a.id !== id && (a.percentage + roundingError) >= 0) || finalActivities.find(a => a.id === id);
                        if (activityToAdjust) activityToAdjust.percentage += roundingError;
                    }
                    
                    return finalActivities.map(a => ({...a, percentage: Math.round(a.percentage)}));
                });
            };

            const handleTimeChange = (e) => {
                const { name, value } = e.target;
                const currentHours = Math.floor(totalTimeInSeconds / 3600);
                const currentMinutes = Math.floor((totalTimeInSeconds % 3600) / 60);
                let newHours = currentHours, newMinutes = currentMinutes;
                if (name === 'hours') newHours = parseInt(value, 10) || 0;
                if (name === 'minutes') newMinutes = parseInt(value, 10) || 0;
                setTotalTimeInSeconds(newHours * 3600 + newMinutes * 60);
            };

            const handleStartTimer = () => {
                if (totalPercentage !== 100) return;
                let remainingSeconds = totalTimeInSeconds;
                const calculated = setupActivities.map(activity => {
                    const duration = Math.floor(totalTimeInSeconds * (activity.percentage / 100));
                    remainingSeconds -= duration;
                    return { ...activity, duration, remainingDuration: duration, timeSpent: 0 };
                });
                if(remainingSeconds > 0 && calculated.length > 0) {
                    calculated.sort((a,b) => b.duration - a.duration)[0].remainingDuration += remainingSeconds;
                }
                setSessionActivities(calculated.sort((a,b) => a.id - b.id));
                setTimerState({isActive: true, currentActivityIndex: 0, totalTimeRemaining: totalTimeInSeconds});
                setScreen('timer');
            };

            const handleReset = () => {
                setTimerState({ isActive: false, currentActivityIndex: 0, totalTimeRemaining: 0 });
                setSessionActivities([]);
                setScreen('setup');
            };
            
            const handlePauseToggle = () => setTimerState(prev => ({ ...prev, isActive: !prev.isActive }));
            const handleSwitchActivit